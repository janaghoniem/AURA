# ============================================================================
# UNIFIED EXECUTION ROUTER - DESKTOP & WEB
# ============================================================================
# This module routes tasks to the appropriate execution agent based on context

import asyncio
import logging
from typing import Dict, Any, Optional
from enum import Enum

logger = logging.getLogger(__name__)

# ============================================================================
# Execution Context Enum
# ============================================================================

class ExecutionContext(Enum):
    """Execution context types"""
    LOCAL = "local"      # Desktop automation (pywinauto)
    WEB = "web"          # Browser automation (Playwright)
    HYBRID = "hybrid"    # Mixed workflow

# ============================================================================
# Unified Execution Router
# ============================================================================

class UnifiedExecutionRouter:
    """Routes tasks to desktop or web execution based on context"""
    
    def __init__(self):
        self.desktop_pipeline = None
        self.web_pipeline = None
        self._initialized = {"desktop": False, "web": False}
    
    async def initialize_desktop(self):
        """Initialize desktop execution pipeline"""
        if self._initialized["desktop"]:
            return
        
        try:
            from agents.execution_agent.RAG.execution import (
                SandboxExecutionPipeline,
                SandboxConfig
            )
            
            config = SandboxConfig(timeout_seconds=30)
            self.desktop_pipeline = SandboxExecutionPipeline(config)
            self._initialized["desktop"] = True
            
            logger.info("‚úÖ Desktop execution pipeline initialized")
        except ImportError as e:
            logger.error(f"‚ùå Failed to import desktop execution: {e}")
            raise
    
    async def initialize_web(self):
        """Initialize web execution pipeline"""
        if self._initialized["web"]:
            return
        
        try:
            from web_execution import (
                WebExecutionPipeline,
                WebExecutionConfig
            )
            
            config = WebExecutionConfig(
                headless=False,  # Show browser for debugging
                timeout_seconds=30
            )
            self.web_pipeline = WebExecutionPipeline(config)
            await self.web_pipeline.initialize()
            self._initialized["web"] = True
            
            logger.info("‚úÖ Web execution pipeline initialized")
        except ImportError as e:
            logger.error(f"‚ùå Failed to import web execution: {e}")
            raise
    
    async def execute_task(
        self,
        task: Dict[str, Any],
        session_id: str = "default"
    ) -> Dict[str, Any]:
        """Route and execute task based on context"""
        
        context = task.get("context", "local")
        task_id = task.get("task_id", "unknown")
        
        logger.info(f"üìç Routing task {task_id} (context: {context})")
        
        # Route to appropriate pipeline
        if context == "local":
            return await self._execute_desktop(task, session_id)
        elif context == "web":
            return await self._execute_web(task, session_id)
        else:
            raise ValueError(f"Invalid context: {context}")
    
    async def _execute_desktop(
        self,
        task: Dict[str, Any],
        session_id: str
    ) -> Dict[str, Any]:
        """Execute desktop automation task"""
        
        # Ensure desktop pipeline is initialized
        if not self._initialized["desktop"]:
            await self.initialize_desktop()
        
        logger.info("üñ•Ô∏è Executing desktop task...")
        
        # Build RAG query from task
        ai_prompt = task.get("ai_prompt", "")
        
        # Use RAG to generate desktop automation code
        from agents.execution_agent.RAG.code_generation import RAGSystem, RAGConfig
        
        rag_config = RAGConfig(library_name="pywinauto")
        rag_system = RAGSystem(rag_config)
        rag_system.initialize()
        
        # Generate code
        rag_result = rag_system.generate_code(ai_prompt)
        generated_code = rag_result.get('code', '')
        
        if not generated_code:
            return {
                "task_id": task["task_id"],
                "status": "failed",
                "error": "No code generated by RAG system"
            }
        
        # Execute in desktop sandbox
        exec_result = self.desktop_pipeline.execute_code(
            code=generated_code,
            use_docker=False
        )
        
        return {
            "task_id": task["task_id"],
            "status": "success" if exec_result.validation_passed else "failed",
            "content": exec_result.stdout if exec_result.validation_passed else None,
            "error": None if exec_result.validation_passed else ", ".join(exec_result.validation_errors)
        }
    
    async def _execute_web(
        self,
        task: Dict[str, Any],
        session_id: str
    ) -> Dict[str, Any]:
        """Execute web automation task"""
        
        # Ensure web pipeline is initialized
        if not self._initialized["web"]:
            await self.initialize_web()
        
        logger.info("üåê Executing web task...")
        
        # Execute via Playwright
        exec_result = await self.web_pipeline.execute_web_task(task, session_id)
        
        return {
            "task_id": task["task_id"],
            "status": "success" if exec_result.validation_passed else "failed",
            "content": exec_result.output if exec_result.validation_passed else None,
            "error": None if exec_result.validation_passed else exec_result.error,
            "extracted_data": exec_result.extracted_data,
            "screenshot": exec_result.screenshot_path
        }
    
    async def cleanup(self):
        """Cleanup all pipelines"""
        if self.web_pipeline:
            await self.web_pipeline.cleanup()
        
        logger.info("üßπ Unified router cleanup complete")

# ============================================================================
# Broker Integration (Updated for coordinator_agent.py)
# ============================================================================

async def start_unified_execution_agent(broker_instance):
    """Start unified execution agent that handles both desktop and web tasks"""
    
    router = UnifiedExecutionRouter()
    
    async def handle_execution_request(message):
        """Handle execution request from coordinator"""
        try:
            task_data = message.payload
            task_id = task_data.get('task_id', 'unknown')
            context = task_data.get('context', 'local')
            
            logger.info(f"üéØ Unified execution agent received task {task_id} (context: {context})")
            
            # Route and execute
            result = await router.execute_task(task_data, session_id=message.session_id)
            
            # Send result back to coordinator
            from agents.utils.protocol import AgentMessage, MessageType, AgentType, Channels
            
            response_msg = AgentMessage(
                message_type=MessageType.EXECUTION_RESPONSE,
                sender=AgentType.EXECUTION,
                receiver=AgentType.COORDINATOR,
                session_id=message.session_id,
                task_id=task_id,
                response_to=message.message_id,
                payload=result
            )
            
            await broker_instance.publish(Channels.EXECUTION_TO_COORDINATOR, response_msg)
            logger.info(f"‚úÖ Sent result for task {task_id}: {result['status']}")
            
        except Exception as e:
            logger.error(f"‚ùå Error processing execution request: {e}")
            import traceback
            traceback.print_exc()
            
            error_result = {
                "task_id": message.task_id or "unknown",
                "status": "failed",
                "error": str(e)
            }
            
            from agents.utils.protocol import AgentMessage, MessageType, AgentType, Channels
            
            error_msg = AgentMessage(
                message_type=MessageType.EXECUTION_RESPONSE,
                sender=AgentType.EXECUTION,
                receiver=AgentType.COORDINATOR,
                session_id=message.session_id,
                task_id=message.task_id,
                response_to=message.message_id,
                payload=error_result
            )
            
            await broker_instance.publish(Channels.EXECUTION_TO_COORDINATOR, error_msg)
    
    from agents.utils.protocol import Channels
    broker_instance.subscribe(Channels.COORDINATOR_TO_EXECUTION, handle_execution_request)
    
    logger.info("‚úÖ Unified Execution Agent started (Desktop + Web)")
    
    while True:
        await asyncio.sleep(1)

# ============================================================================
# Example Usage
# ============================================================================

async def test_unified_routing():
    """Test unified routing with mixed tasks"""
    
    router = UnifiedExecutionRouter()
    
    # Desktop task
    desktop_task = {
        "task_id": "desktop_1",
        "ai_prompt": "Open Notepad and type 'Hello from desktop'",
        "context": "local",
        "extra_params": {"app_name": "notepad"}
    }
    
    # Web task
    web_task = {
        "task_id": "web_1",
        "ai_prompt": "Navigate to Google and search for 'Playwright Python'",
        "context": "web",
        "web_params": {
            "url": "https://google.com",
            "action": "navigate"
        }
    }
    
    # Execute both
    print("\nüìã Testing Desktop Task...")
    desktop_result = await router.execute_task(desktop_task)
    print(f"Desktop Result: {desktop_result['status']}")
    
    print("\nüìã Testing Web Task...")
    web_result = await router.execute_task(web_task)
    print(f"Web Result: {web_result['status']}")
    
    # Cleanup
    await router.cleanup()

if __name__ == "__main__":
    asyncio.run(test_unified_routing())